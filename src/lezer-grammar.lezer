@top LezerGrammar { definition* }

@skip { whitespace | LineComment | BlockComment }

at<term> { Keyword { term } }
braced<body> { "{" body? "}" }
commaDelim<item> { item ("," item)* }
barDelim<item> { item ("|" item)* }

definition {
  TopDefinition |
  TokensDefinition { at<"@tokens"> TokensDefinitionBody } |
  PrecedenceDefinition { at<"@precedence"> braced<precedenceList> } |
  DetectDelimDefinition { at<"@detectDelim"> } |
  SkipDefinition |
  _ExternalDefinition |
  RuleDefinition
}

TopDefinition {
  at<"@top"> RuleName? braced<ruleChoice>
}

SkipDefinition {
  at<"@skip"> braced<ruleChoice> braced<RuleDefinition>?
}

identifier {
  capitalizedIdentifier |
  normalIdentifier
}

/* a template application can be resolved to either a token template or a rule template */
templateArguments {
  "<" commaDelim< TemplateArgument { tokenOrRuleChoice } > ">"
}

templateVariables {
  "<" commaDelim< TemplateVariable { identifier } > ">"
}

TokenName { identifier }
TokenSignature { TokenName templateVariables? nodePropsTag? }

TokensDefinitionBody { braced<tokenDefinition+> }

tokenDefinition {
  (TokenDefinition {
    StringLiteral nodePropsTag? |
    TokenSignature braced<tokenChoice>
  } |
  TokenPrecedenceDefinition {
    at<"@precedence"> braced<tokenPrecedenceList>
  })
}

RuleDefinitionBody { braced<ruleChoice> }

RuleDefinition {
  at<"@export">? RuleSignature RuleDefinitionBody
}

inlineRuleDefinition {
  /* a rule definition but cannot be as a template. */
  RuleName nodePropsTag? braced<ruleChoice>
}

nodePropsTag {
  "[" commaDelim< PropAssignment > "]"
}

RuleName { identifier }
RuleSignature { RuleName templateVariables? nodePropsTag? }

PropName { normalIdentifier }
PropAssignment {
  PropName "="
  PropValue {
    (identifier | StringLiteral | "." | "{" identifier "}")+
  }
}

tokenOrRuleChoice { barDelim<TokenOrRuleSeq> }

TokenOrRuleSeq {
  (maybeWithRepeatSpec<ruleExpression |
                       RangeLiteral |
                       "(" tokenOrRuleChoice ")"> |
   PrecedenceMarker |
   AmbiguityMarker)+
}

tokenChoice { barDelim<TokenSeq> }

TokenSeq {
  (maybeWithRepeatSpec<Token |
                       RangeLiteral |
                       "(" tokenChoice ")">)+
}

specialization<type> {
  type
  nodePropsTag?
  "<" tokenChoice "," tokenChoice ">"
}

ruleChoice { barDelim<RuleSeq> }

ruleExpression {
  identifier templateArguments? |
  StringLiteral |
  /* a token is covered in above cases */
  inlineRuleDefinition |
  specialization<at<"@specialize">> |
  specialization<at<"@extend">>
}

RuleSeq {
  (maybeWithRepeatSpec<ruleExpression |
                       "(" ruleChoice ")"> |
   NestedGrammarExpression |
   PrecedenceMarker |
   AmbiguityMarker)+
}

NestedGrammarExpression {
  NestedGrammarName
  ("<" tokenChoice ("," ruleChoice)? ">")?
}

withRepeatSpec<content, c> {
  (_spec[name=Specifier{c}] { content } c)
}

maybeWithRepeatSpec<content> {
  content |
  withRepeatSpec<content, "*"> |
  withRepeatSpec<content, "?"> |
  withRepeatSpec<content, "+">
}

Token {
  TokenName |
  StringLiteral |
  @specialize[name=TokenAny]<normalIdentifier, "_">
}

precedenceList {
  commaDelim<precedenceSpecifier>
}

tokenPrecedenceList {
  commaDelim<TokenName>
}

precedenceSpecifier {
  PrecedenceMarkerName { identifier }
  PrecedenceType { at<"@left"> | at<"@right"> | at<"@cut"> }?
}

ExternalSource { StringLiteral }

_ExternalDefinition {
  (ExternalTokenDefinition {
    at<"@external"> "tokens"
    TokenName "from" ExternalSource braced<commaDelim<TokenSignature>>
  } |
  ExternalPropNameDefinition {
    at<"@external"> "prop"
    PropName "from" ExternalSource
  } |
  ExternalGrammarDefinition {
    at<"@external"> "grammar"
    ExternalParserName { normalIdentifier } ("from" ExternalSource | "empty")
  })
}

@tokens {
  whitespace { std.whitespace+ }

  LineComment { "//" ![\r\n]* }
  BlockComment { "/*" blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  identifierHead { std.asciiLetter | $[_\u{a1}-\u{10ffff}] }
  identifierTail { (identifierHead | std.digit)* }
  capitalizedIdentifier { std.asciiUppercase identifierTail }
  normalIdentifier { identifierHead identifierTail }

  @precedence { capitalizedIdentifier, normalIdentifier, whitespace }

  PrecedenceMarker { "!" normalIdentifier }
  AmbiguityMarker { "~" normalIdentifier }

  StringLiteral {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  // no "-" (0x2d) and "\\" (0x5c)
  rangeChar { $[\u{20}-\u{2c}\u{2e}-\u{5b}\u{5d}-\u{10ffff}] }
  hex  { $[0-9a-fA-F] }
  rangeEscapeSequence {
    "\\u{" hex+ "}" |
    "\\u" hex hex hex hex |
    "\\x" hex hex |
    "\\" ![ux]
  }

  StdRangeLiteral {
    "std." normalIdentifier
  }

  RangeLiteral {
    (("$" | "!") "[" rangeLiteralInner* "]") |
    StdRangeLiteral
  }
  rangeLiteralChar { rangeChar | rangeEscapeSequence }
  rangeLiteralInner {
    rangeLiteralChar ("-" rangeLiteralChar)?
  }

  @precedence { RangeLiteral, normalIdentifier }

  NestedGrammarName {
    "nest." normalIdentifier
  }

  @precedence { NestedGrammarName, normalIdentifier }
}

@detectDelim
